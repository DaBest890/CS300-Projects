# CS 300 Project One – Portfolio Reflection

## Reflection

**What was the problem you were solving in the projects for this course?**  
The objective of the project was to develop a program to support academic advisors by organizing and displaying course information. Specifically, the program needed to load course data from a file, display a list of all computer science courses in alphanumeric order, and provide detailed information and prerequisites for a specific course upon request.

**How did you approach the problem?**  
I began by analyzing the requirements and identifying which data structures—vector, hash table, and binary search tree—could best address each task. I broke the problem into modular components, such as file reading, course object creation, and data organization, then implemented pseudocode for each structure. Understanding data structures was essential, as their properties (e.g., search speed, ordering, memory use) directly impacted both performance and maintainability.

**How did you overcome any roadblocks you encountered while going through the activities or project?**  
One of the main challenges I faced was designing pseudocode that could efficiently sort and retrieve course data depending on the structure used. I revisited Big O complexity principles to evaluate runtime behavior, which helped clarify the trade-offs between data structure choices. I also iterated on feedback from earlier milestones to refine my approach, ensuring a more robust final submission.

**How has your work on this project expanded your approach to designing software and developing programs?**  
This project reinforced the importance of selecting the right data structure during the planning phase. It also taught me to design for flexibility by separating concerns—file handling, object modeling, and display logic. By building a reusable structure in pseudocode before coding, I developed a stronger architectural mindset that will benefit future development work.

**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**  
I’ve learned to emphasize clarity and modularity in both pseudocode and real code. Using meaningful naming conventions, limiting nested logic, and structuring the program into logical sections has made it easier to test, update, and reuse. As a result, I now approach every program with the intent to make it easy to read and extend—not just to make it work.
